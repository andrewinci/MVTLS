\hypertarget{_server_client_transport_protocol_8c}{}\section{src/\+Server\+Client\+Transport\+Protocol.c File Reference}
\label{_server_client_transport_protocol_8c}\index{src/\+Server\+Client\+Transport\+Protocol.\+c@{src/\+Server\+Client\+Transport\+Protocol.\+c}}
{\ttfamily \#include \char`\"{}Server\+Client\+Transport\+Protocol.\+h\char`\"{}}\\*
Include dependency graph for Server\+Client\+Transport\+Protocol.\+c\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{_server_client_transport_protocol_8c_a52cb1d528c2a550d4d440abeb90e1ea7}{free\+\_\+packet} (\hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$p)
\item 
long long \hyperlink{_server_client_transport_protocol_8c_a4355b2213c5d049d51944ea7c5126532}{get\+\_\+file\+\_\+size} (int fd)
\item 
uint32\+\_\+t \hyperlink{_server_client_transport_protocol_8c_a41dd4a03c0fcb9195dac633e86be6877}{read\+\_\+all\+\_\+file} (int fd, unsigned char $\ast$$\ast$p)
\item 
\hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$ \hyperlink{_server_client_transport_protocol_8c_ad5ca31599ddc0387256db843d883cf32}{deserialize\+\_\+packet} (unsigned char $\ast$str, uint32\+\_\+t file\+Len)
\item 
void \hyperlink{_server_client_transport_protocol_8c_afbd56244da58120495a233d0fc080223}{serialize\+\_\+packet} (\hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$p, unsigned char $\ast$$\ast$str, uint32\+\_\+t $\ast$str\+Len)
\item 
\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ \hyperlink{_server_client_transport_protocol_8c_aaa07b9b9152780bcb7fbacf14efa7eda}{create\+\_\+channel} (char $\ast$file\+Name, char $\ast$channel\+From, char $\ast$channel\+To)
\item 
int \hyperlink{_server_client_transport_protocol_8c_a018090dd0ba292fbef485142a080fa59}{set\+\_\+on\+\_\+receive} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, void($\ast$\hyperlink{server_8c_a48f2c3c739d443cf2dd46c01a7136674}{on\+Packet\+Receive})(\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, \hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$p))
\item 
void \hyperlink{_server_client_transport_protocol_8c_acc975c295cc4a9e275948e333c45598e}{reader} (void $\ast$data)
\item 
int \hyperlink{_server_client_transport_protocol_8c_ac13189fb7b788d6f0360927759b95a8b}{start\+\_\+listener} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
void \hyperlink{_server_client_transport_protocol_8c_aa8b8d9b75a74ccb0f6a701e16ae8999d}{stop\+\_\+channel} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
void \hyperlink{_server_client_transport_protocol_8c_a771a2acdb87f3679abacac37706d65d7}{wait\+\_\+channel} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
\hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$ \hyperlink{_server_client_transport_protocol_8c_ab900c15a013c9cb71d24f3e7f5479822}{create\+\_\+packet} (char $\ast$source, char $\ast$destination, unsigned char $\ast$message, uint32\+\_\+t message\+\_\+length)
\item 
int \hyperlink{_server_client_transport_protocol_8c_aaf312ea4a4b413a2bbad6f1cd180f4ac}{send\+\_\+packet} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, \hyperlink{structpacket__transport__t}{packet\+\_\+transport\+\_\+t} $\ast$p)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
S\+S\+L/\+T\+LS Project

Basic client/server communication through file. It substitutes the transport layer in O\+SI stack.

P\+R\+O\+T\+O\+C\+OL\+: The protocol is very simple 8 byte for source 8 byte for receiver 4 byte for packet length message

Both server and client, after reading a message, blank the file Both server and client cannot write if the file is not blank, they wait

\begin{DoxyDate}{Date}
Created on 22/12/15. 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright Â© 2015 Alessandro Melloni, Andrea Francesco Vinci. All rights reserved. 
\end{DoxyCopyright}


\subsection{Function Documentation}
\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!create\+\_\+channel@{create\+\_\+channel}}
\index{create\+\_\+channel@{create\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{create\+\_\+channel(char $\ast$file\+Name, char $\ast$channel\+From, char $\ast$channel\+To)}{create_channel(char *fileName, char *channelFrom, char *channelTo)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf channel\+\_\+t}$\ast$ create\+\_\+channel (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Name, }
\item[{char $\ast$}]{channel\+From, }
\item[{char $\ast$}]{channel\+To}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_aaa07b9b9152780bcb7fbacf14efa7eda}{}\label{_server_client_transport_protocol_8c_aaa07b9b9152780bcb7fbacf14efa7eda}
Create a server/client channel using the file\+Name as communication channel


\begin{DoxyParams}{Parameters}
{\em file\+Name} & file name of the channel \\
\hline
{\em channel\+From} & name of the channel owner \\
\hline
{\em channel\+To} & name of the other peer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the created channel 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().



Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_aaa07b9b9152780bcb7fbacf14efa7eda_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!create\+\_\+packet@{create\+\_\+packet}}
\index{create\+\_\+packet@{create\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{create\+\_\+packet(char $\ast$source, char $\ast$destination, unsigned char $\ast$message, uint32\+\_\+t message\+\_\+length)}{create_packet(char *source, char *destination, unsigned char *message, uint32_t message_length)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf packet\+\_\+transport\+\_\+t}$\ast$ create\+\_\+packet (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{source, }
\item[{char $\ast$}]{destination, }
\item[{unsigned char $\ast$}]{message, }
\item[{uint32\+\_\+t}]{message\+\_\+length}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_ab900c15a013c9cb71d24f3e7f5479822}{}\label{_server_client_transport_protocol_8c_ab900c15a013c9cb71d24f3e7f5479822}
Create a packet starting from a byte stream source and destination


\begin{DoxyParams}{Parameters}
{\em source} & packet source \\
\hline
{\em destination} & packet receiver \\
\hline
{\em message} & message stream to be encapsulated into packet \\
\hline
{\em message\+\_\+length} & message lenght \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a built packet 
\end{DoxyReturn}


Referenced by deserialize\+\_\+packet(), and send\+\_\+record().



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_ab900c15a013c9cb71d24f3e7f5479822_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!deserialize\+\_\+packet@{deserialize\+\_\+packet}}
\index{deserialize\+\_\+packet@{deserialize\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{deserialize\+\_\+packet(unsigned char $\ast$str, uint32\+\_\+t file\+Len)}{deserialize_packet(unsigned char *str, uint32_t fileLen)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf packet\+\_\+transport\+\_\+t} $\ast$ deserialize\+\_\+packet (
\begin{DoxyParamCaption}
\item[{unsigned char $\ast$}]{str, }
\item[{uint32\+\_\+t}]{file\+Len}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_ad5ca31599ddc0387256db843d883cf32}{}\label{_server_client_transport_protocol_8c_ad5ca31599ddc0387256db843d883cf32}
De-\/serialize message into a transport packet


\begin{DoxyParams}{Parameters}
{\em str} & string received \\
\hline
{\em file\+Len} & received string length \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the de-\/serialized message as transport struct 
\end{DoxyReturn}


Referenced by reader().



Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=296pt]{_server_client_transport_protocol_8c_ad5ca31599ddc0387256db843d883cf32_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_ad5ca31599ddc0387256db843d883cf32_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!free\+\_\+packet@{free\+\_\+packet}}
\index{free\+\_\+packet@{free\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{free\+\_\+packet(packet\+\_\+transport\+\_\+t $\ast$p)}{free_packet(packet_transport_t *p)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+\_\+packet (
\begin{DoxyParamCaption}
\item[{{\bf packet\+\_\+transport\+\_\+t} $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_a52cb1d528c2a550d4d440abeb90e1ea7}{}\label{_server_client_transport_protocol_8c_a52cb1d528c2a550d4d440abeb90e1ea7}
Deallocate memory allocated by packet 
\begin{DoxyParams}{Parameters}
{\em p} & pointer to packet to free \\
\hline
\end{DoxyParams}


Referenced by on\+Packet\+Receive(), reader(), and send\+\_\+record().



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_a52cb1d528c2a550d4d440abeb90e1ea7_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!get\+\_\+file\+\_\+size@{get\+\_\+file\+\_\+size}}
\index{get\+\_\+file\+\_\+size@{get\+\_\+file\+\_\+size}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{get\+\_\+file\+\_\+size(int fd)}{get_file_size(int fd)}}]{\setlength{\rightskip}{0pt plus 5cm}long long get\+\_\+file\+\_\+size (
\begin{DoxyParamCaption}
\item[{int}]{fd}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_a4355b2213c5d049d51944ea7c5126532}{}\label{_server_client_transport_protocol_8c_a4355b2213c5d049d51944ea7c5126532}
Compute the byte size of a file


\begin{DoxyParams}{Parameters}
{\em fd} & file descriptor \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the length of the file in byte 
\end{DoxyReturn}


Referenced by read\+\_\+all\+\_\+file(), and send\+\_\+packet().



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_a4355b2213c5d049d51944ea7c5126532_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!read\+\_\+all\+\_\+file@{read\+\_\+all\+\_\+file}}
\index{read\+\_\+all\+\_\+file@{read\+\_\+all\+\_\+file}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{read\+\_\+all\+\_\+file(int fd, unsigned char $\ast$$\ast$p)}{read_all_file(int fd, unsigned char **p)}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t read\+\_\+all\+\_\+file (
\begin{DoxyParamCaption}
\item[{int}]{fd, }
\item[{unsigned char $\ast$$\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_a41dd4a03c0fcb9195dac633e86be6877}{}\label{_server_client_transport_protocol_8c_a41dd4a03c0fcb9195dac633e86be6877}
Read the entire file and store it in the provided pointer


\begin{DoxyParams}{Parameters}
{\em fd} & file descriptor \\
\hline
{\em p} & return pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the file size 
\end{DoxyReturn}


Referenced by reader().



Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=258pt]{_server_client_transport_protocol_8c_a41dd4a03c0fcb9195dac633e86be6877_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_a41dd4a03c0fcb9195dac633e86be6877_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!reader@{reader}}
\index{reader@{reader}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{reader(void $\ast$data)}{reader(void *data)}}]{\setlength{\rightskip}{0pt plus 5cm}void reader (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{data}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_acc975c295cc4a9e275948e333c45598e}{}\label{_server_client_transport_protocol_8c_acc975c295cc4a9e275948e333c45598e}
Listener on the file. This function continuously read the entire file until the message is for the channel owner. The cycle halt when the stop\+\_\+channel function is called and start with start\+\_\+listener.


\begin{DoxyParams}{Parameters}
{\em data} & a pointer to the channel. \\
\hline
\end{DoxyParams}


Referenced by start\+\_\+listener().



Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_acc975c295cc4a9e275948e333c45598e_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_acc975c295cc4a9e275948e333c45598e_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!send\+\_\+packet@{send\+\_\+packet}}
\index{send\+\_\+packet@{send\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{send\+\_\+packet(channel\+\_\+t $\ast$ch, packet\+\_\+transport\+\_\+t $\ast$p)}{send_packet(channel_t *ch, packet_transport_t *p)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+packet (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch, }
\item[{{\bf packet\+\_\+transport\+\_\+t} $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_aaf312ea4a4b413a2bbad6f1cd180f4ac}{}\label{_server_client_transport_protocol_8c_aaf312ea4a4b413a2bbad6f1cd180f4ac}
Send a message through the channel ch


\begin{DoxyParams}{Parameters}
{\em ch} & channel to be used \\
\hline
{\em p} & pointer to packet to be sent \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the message was sent, 0 otherwise 
\end{DoxyReturn}


Referenced by send\+\_\+record().



Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=278pt]{_server_client_transport_protocol_8c_aaf312ea4a4b413a2bbad6f1cd180f4ac_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_aaf312ea4a4b413a2bbad6f1cd180f4ac_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!serialize\+\_\+packet@{serialize\+\_\+packet}}
\index{serialize\+\_\+packet@{serialize\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{serialize\+\_\+packet(packet\+\_\+transport\+\_\+t $\ast$p, unsigned char $\ast$$\ast$str, uint32\+\_\+t $\ast$str\+Len)}{serialize_packet(packet_transport_t *p, unsigned char **str, uint32_t *strLen)}}]{\setlength{\rightskip}{0pt plus 5cm}void serialize\+\_\+packet (
\begin{DoxyParamCaption}
\item[{{\bf packet\+\_\+transport\+\_\+t} $\ast$}]{p, }
\item[{unsigned char $\ast$$\ast$}]{str, }
\item[{uint32\+\_\+t $\ast$}]{str\+Len}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_afbd56244da58120495a233d0fc080223}{}\label{_server_client_transport_protocol_8c_afbd56244da58120495a233d0fc080223}
Serialize the packet into a byte stream


\begin{DoxyParams}{Parameters}
{\em p} & packet to serialize \\
\hline
{\em str} & pointer to a null string (used to return the stream) \\
\hline
{\em str\+Len} & pointer to stream length (used to return the stream length) \\
\hline
\end{DoxyParams}


Referenced by send\+\_\+packet().



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_afbd56244da58120495a233d0fc080223_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!set\+\_\+on\+\_\+receive@{set\+\_\+on\+\_\+receive}}
\index{set\+\_\+on\+\_\+receive@{set\+\_\+on\+\_\+receive}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{set\+\_\+on\+\_\+receive(channel\+\_\+t $\ast$ch, void($\ast$on\+Packet\+Receive)(channel\+\_\+t $\ast$ch, packet\+\_\+transport\+\_\+t $\ast$p))}{set_on_receive(channel_t *ch, void(*onPacketReceive)(channel_t *ch, packet_transport_t *p))}}]{\setlength{\rightskip}{0pt plus 5cm}int set\+\_\+on\+\_\+receive (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch, }
\item[{void($\ast$)({\bf channel\+\_\+t} $\ast$ch, {\bf packet\+\_\+transport\+\_\+t} $\ast$p)}]{on\+Packet\+Receive}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_a018090dd0ba292fbef485142a080fa59}{}\label{_server_client_transport_protocol_8c_a018090dd0ba292fbef485142a080fa59}
Set the function to be called when a message is received


\begin{DoxyParams}{Parameters}
{\em ch} & channel interested \\
\hline
{\em on\+Packet\+Receive} & pointer to the function to call \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the function was set, 0 otherwise 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().



Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_a018090dd0ba292fbef485142a080fa59_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_a018090dd0ba292fbef485142a080fa59_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!start\+\_\+listener@{start\+\_\+listener}}
\index{start\+\_\+listener@{start\+\_\+listener}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{start\+\_\+listener(channel\+\_\+t $\ast$ch)}{start_listener(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}int start\+\_\+listener (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_ac13189fb7b788d6f0360927759b95a8b}{}\label{_server_client_transport_protocol_8c_ac13189fb7b788d6f0360927759b95a8b}
Start the channel. We open another thread for the reading and the current thread for writing. From now on (if the operation is succesfull) the client/server read continously from channel. (to S\+T\+OP use stop())


\begin{DoxyParams}{Parameters}
{\em ch} & channel to start \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the thread was started, 0 otherwise 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().



Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_ac13189fb7b788d6f0360927759b95a8b_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{_server_client_transport_protocol_8c_ac13189fb7b788d6f0360927759b95a8b_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!stop\+\_\+channel@{stop\+\_\+channel}}
\index{stop\+\_\+channel@{stop\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{stop\+\_\+channel(channel\+\_\+t $\ast$ch)}{stop_channel(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}void stop\+\_\+channel (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_aa8b8d9b75a74ccb0f6a701e16ae8999d}{}\label{_server_client_transport_protocol_8c_aa8b8d9b75a74ccb0f6a701e16ae8999d}
Stop the reading/writing thread and the channel. Note\+: the function doesn\textquotesingle{}t free the channel. 
\begin{DoxyParams}{Parameters}
{\em ch} & channel to stop \\
\hline
\end{DoxyParams}


Referenced by on\+Packet\+Receive().



Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_server_client_transport_protocol_8c_aa8b8d9b75a74ccb0f6a701e16ae8999d_icgraph}
\end{center}
\end{figure}


\index{Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}!wait\+\_\+channel@{wait\+\_\+channel}}
\index{wait\+\_\+channel@{wait\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+c@{Server\+Client\+Transport\+Protocol.\+c}}
\subsubsection[{\texorpdfstring{wait\+\_\+channel(channel\+\_\+t $\ast$ch)}{wait_channel(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}void wait\+\_\+channel (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8c_a771a2acdb87f3679abacac37706d65d7}{}\label{_server_client_transport_protocol_8c_a771a2acdb87f3679abacac37706d65d7}
Stop the caller and wait until stop() is called 
\begin{DoxyParams}{Parameters}
{\em ch} & the channel to wait \\
\hline
\end{DoxyParams}


Referenced by do\+\_\+handshake().



Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{_server_client_transport_protocol_8c_a771a2acdb87f3679abacac37706d65d7_icgraph}
\end{center}
\end{figure}


