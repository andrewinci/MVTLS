\hypertarget{_server_client_transport_protocol_8h}{}\section{/\+Users/\+Darka/\+Dropbox/\+U\+N\+I\+T\+N/\+Advanced\+Programming/\+Project/include/\+Server\+Client\+Transport\+Protocol.h File Reference}
\label{_server_client_transport_protocol_8h}\index{/\+Users/\+Darka/\+Dropbox/\+U\+N\+I\+T\+N/\+Advanced\+Programming/\+Project/include/\+Server\+Client\+Transport\+Protocol.\+h@{/\+Users/\+Darka/\+Dropbox/\+U\+N\+I\+T\+N/\+Advanced\+Programming/\+Project/include/\+Server\+Client\+Transport\+Protocol.\+h}}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$stdint.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$unistd.\+h$>$}\\*
{\ttfamily \#include $<$sys/wait.\+h$>$}\\*
{\ttfamily \#include $<$sys/file.\+h$>$}\\*
{\ttfamily \#include $<$sys/stat.\+h$>$}\\*
{\ttfamily \#include $<$pthread.\+h$>$}\\*
{\ttfamily \#include $<$time.\+h$>$}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpacket__basic__t}{packet\+\_\+basic\+\_\+t}
\item 
struct \hyperlink{structchannel__t}{channel\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{_server_client_transport_protocol_8h_a898f8c58e7f9295dcd48d081926f82ca}{D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME}~50
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structchannel__t}{channel\+\_\+t} \hyperlink{_server_client_transport_protocol_8h_a23109d98b407095c0ef9fd921ac30b81}{channel\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ \hyperlink{_server_client_transport_protocol_8h_aaa07b9b9152780bcb7fbacf14efa7eda}{create\+\_\+channel} (char $\ast$file\+Name, char $\ast$channel\+From, char $\ast$channel\+To)
\item 
int \hyperlink{_server_client_transport_protocol_8h_ab8b2348db6f622cb7334a743187f0ac0}{set\+\_\+on\+\_\+receive} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, void($\ast$\hyperlink{server_8c_acf4f7155469cbb30edfa846d620b099b}{on\+Packet\+Receive})(\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, \hyperlink{structpacket__basic__t}{packet\+\_\+basic\+\_\+t} $\ast$p))
\item 
int \hyperlink{_server_client_transport_protocol_8h_a984177c20c9bdc900b4c1e2cb33165cb}{send\+\_\+packet} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch, \hyperlink{structpacket__basic__t}{packet\+\_\+basic\+\_\+t} $\ast$p)
\item 
int \hyperlink{_server_client_transport_protocol_8h_ac13189fb7b788d6f0360927759b95a8b}{start\+\_\+listener} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
void \hyperlink{_server_client_transport_protocol_8h_a771a2acdb87f3679abacac37706d65d7}{wait\+\_\+channel} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
void \hyperlink{_server_client_transport_protocol_8h_aa8b8d9b75a74ccb0f6a701e16ae8999d}{stop\+\_\+channel} (\hyperlink{structchannel__t}{channel\+\_\+t} $\ast$ch)
\item 
\hyperlink{structpacket__basic__t}{packet\+\_\+basic\+\_\+t} $\ast$ \hyperlink{_server_client_transport_protocol_8h_a15f2b44261f5f05f631243058273ff80}{create\+\_\+packet} (char $\ast$source, char $\ast$destination, unsigned char $\ast$message, uint32\+\_\+t message\+\_\+length)
\item 
void \hyperlink{_server_client_transport_protocol_8h_a7e53c8ac07852acb8cc5bf863af20f68}{free\+\_\+packet} (\hyperlink{structpacket__basic__t}{packet\+\_\+basic\+\_\+t} $\ast$p)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
S\+S\+L/\+T\+LS Project

Basic client/server communication through file.

P\+R\+O\+T\+O\+C\+OL\+: The protocol is very simple 8 byte for source 8 byte for receiver 4 byte for packet length message

both server and client after read a message they blank the file both server and client cannot write if the file is not blank, they wait

\begin{DoxyDate}{Date}
Created on 22/12/15. 
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright Â© 2015 Alessandro Melloni, Andrea Francesco Vinci. All rights reserved. 
\end{DoxyCopyright}


\subsection{Macro Definition Documentation}
\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME@{D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME}}
\index{D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME@{D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME}{DELAY_TIME}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+L\+A\+Y\+\_\+\+T\+I\+ME~50}\hypertarget{_server_client_transport_protocol_8h_a898f8c58e7f9295dcd48d081926f82ca}{}\label{_server_client_transport_protocol_8h_a898f8c58e7f9295dcd48d081926f82ca}


Referenced by reader().



\subsection{Typedef Documentation}
\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!channel\+\_\+t@{channel\+\_\+t}}
\index{channel\+\_\+t@{channel\+\_\+t}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{channel\+\_\+t}{channel_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf channel\+\_\+t} {\bf channel\+\_\+t}}\hypertarget{_server_client_transport_protocol_8h_a23109d98b407095c0ef9fd921ac30b81}{}\label{_server_client_transport_protocol_8h_a23109d98b407095c0ef9fd921ac30b81}


\subsection{Function Documentation}
\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!create\+\_\+channel@{create\+\_\+channel}}
\index{create\+\_\+channel@{create\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{create\+\_\+channel(char $\ast$file\+Name, char $\ast$channel\+From, char $\ast$channel\+To)}{create_channel(char *fileName, char *channelFrom, char *channelTo)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf channel\+\_\+t}$\ast$ create\+\_\+channel (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Name, }
\item[{char $\ast$}]{channel\+From, }
\item[{char $\ast$}]{channel\+To}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_aaa07b9b9152780bcb7fbacf14efa7eda}{}\label{_server_client_transport_protocol_8h_aaa07b9b9152780bcb7fbacf14efa7eda}
Create a server/client using the file\+Name as comunication channel


\begin{DoxyParams}{Parameters}
{\em file\+Name} & \+: file name of the channel \\
\hline
{\em server\+Name} & \+: name of the server/client \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the created channel 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!create\+\_\+packet@{create\+\_\+packet}}
\index{create\+\_\+packet@{create\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{create\+\_\+packet(char $\ast$source, char $\ast$destination, unsigned char $\ast$message, uint32\+\_\+t message\+\_\+length)}{create_packet(char *source, char *destination, unsigned char *message, uint32_t message_length)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf packet\+\_\+basic\+\_\+t}$\ast$ create\+\_\+packet (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{source, }
\item[{char $\ast$}]{destination, }
\item[{unsigned char $\ast$}]{message, }
\item[{uint32\+\_\+t}]{message\+\_\+length}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_a15f2b44261f5f05f631243058273ff80}{}\label{_server_client_transport_protocol_8h_a15f2b44261f5f05f631243058273ff80}
Create a packet starting from a byte stream source and destination


\begin{DoxyParams}{Parameters}
{\em source} & \+: packet source \\
\hline
{\em destination} & \+: packet receiver \\
\hline
{\em message} & \+: message stream to be encapsulate into packet \\
\hline
{\em message\+\_\+length} & message lenght \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a pointer to a builded packet 
\end{DoxyReturn}


Referenced by deserialize\+\_\+packet(), and send\+\_\+record().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!free\+\_\+packet@{free\+\_\+packet}}
\index{free\+\_\+packet@{free\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{free\+\_\+packet(packet\+\_\+basic\+\_\+t $\ast$p)}{free_packet(packet_basic_t *p)}}]{\setlength{\rightskip}{0pt plus 5cm}void free\+\_\+packet (
\begin{DoxyParamCaption}
\item[{{\bf packet\+\_\+basic\+\_\+t} $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_a7e53c8ac07852acb8cc5bf863af20f68}{}\label{_server_client_transport_protocol_8h_a7e53c8ac07852acb8cc5bf863af20f68}
Deallocate memory allocated by packet 
\begin{DoxyParams}{Parameters}
{\em p} & \+: pointer to packet to free \\
\hline
\end{DoxyParams}


Referenced by on\+Packet\+Receive(), reader(), and send\+\_\+record().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!send\+\_\+packet@{send\+\_\+packet}}
\index{send\+\_\+packet@{send\+\_\+packet}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{send\+\_\+packet(channel\+\_\+t $\ast$ch, packet\+\_\+basic\+\_\+t $\ast$p)}{send_packet(channel_t *ch, packet_basic_t *p)}}]{\setlength{\rightskip}{0pt plus 5cm}int send\+\_\+packet (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch, }
\item[{{\bf packet\+\_\+basic\+\_\+t} $\ast$}]{p}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_a984177c20c9bdc900b4c1e2cb33165cb}{}\label{_server_client_transport_protocol_8h_a984177c20c9bdc900b4c1e2cb33165cb}
Send a message trough the channel ch


\begin{DoxyParams}{Parameters}
{\em ch} & \+: channel to be used \\
\hline
{\em p} & \+: pointer to packet to be sent \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the message was sent, 0 otherwise 
\end{DoxyReturn}


Referenced by send\+\_\+record().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!set\+\_\+on\+\_\+receive@{set\+\_\+on\+\_\+receive}}
\index{set\+\_\+on\+\_\+receive@{set\+\_\+on\+\_\+receive}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{set\+\_\+on\+\_\+receive(channel\+\_\+t $\ast$ch, void($\ast$on\+Packet\+Receive)(channel\+\_\+t $\ast$ch, packet\+\_\+basic\+\_\+t $\ast$p))}{set_on_receive(channel_t *ch, void(*onPacketReceive)(channel_t *ch, packet_basic_t *p))}}]{\setlength{\rightskip}{0pt plus 5cm}int set\+\_\+on\+\_\+receive (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch, }
\item[{void($\ast$)({\bf channel\+\_\+t} $\ast$ch, {\bf packet\+\_\+basic\+\_\+t} $\ast$p)}]{on\+Packet\+Receive}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_ab8b2348db6f622cb7334a743187f0ac0}{}\label{_server_client_transport_protocol_8h_ab8b2348db6f622cb7334a743187f0ac0}
Set the function to be called when a message is received


\begin{DoxyParams}{Parameters}
{\em ch} & \+: channel interested \\
\hline
{\em on\+Packet\+Receive} & \+: pointer to the function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the function was setted, 0 otherwise 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!start\+\_\+listener@{start\+\_\+listener}}
\index{start\+\_\+listener@{start\+\_\+listener}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{start\+\_\+listener(channel\+\_\+t $\ast$ch)}{start_listener(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}int start\+\_\+listener (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_ac13189fb7b788d6f0360927759b95a8b}{}\label{_server_client_transport_protocol_8h_ac13189fb7b788d6f0360927759b95a8b}
Start the channel. We open another thread for the reading and the current thread for writing. From now on (if the operation is succesfull) the client/server read continously from channel. (for S\+T\+OP use stop())


\begin{DoxyParams}{Parameters}
{\em ch} & \+: channel to start \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\+: 1 if the thread was started, 0 otherwise 
\end{DoxyReturn}


Referenced by do\+\_\+handshake().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!stop\+\_\+channel@{stop\+\_\+channel}}
\index{stop\+\_\+channel@{stop\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{stop\+\_\+channel(channel\+\_\+t $\ast$ch)}{stop_channel(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}void stop\+\_\+channel (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_aa8b8d9b75a74ccb0f6a701e16ae8999d}{}\label{_server_client_transport_protocol_8h_aa8b8d9b75a74ccb0f6a701e16ae8999d}
Stop the reading/write thread and the channel. Note\+: the function doesn\textquotesingle{}t free the channel. 
\begin{DoxyParams}{Parameters}
{\em ch} & \+: channel to stop \\
\hline
\end{DoxyParams}


Referenced by on\+Packet\+Receive().

\index{Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}!wait\+\_\+channel@{wait\+\_\+channel}}
\index{wait\+\_\+channel@{wait\+\_\+channel}!Server\+Client\+Transport\+Protocol.\+h@{Server\+Client\+Transport\+Protocol.\+h}}
\subsubsection[{\texorpdfstring{wait\+\_\+channel(channel\+\_\+t $\ast$ch)}{wait_channel(channel_t *ch)}}]{\setlength{\rightskip}{0pt plus 5cm}void wait\+\_\+channel (
\begin{DoxyParamCaption}
\item[{{\bf channel\+\_\+t} $\ast$}]{ch}
\end{DoxyParamCaption}
)}\hypertarget{_server_client_transport_protocol_8h_a771a2acdb87f3679abacac37706d65d7}{}\label{_server_client_transport_protocol_8h_a771a2acdb87f3679abacac37706d65d7}
Stop the callee and wait untill stop is called 
\begin{DoxyParams}{Parameters}
{\em ch} & \+: the chanal to wait \\
\hline
\end{DoxyParams}


Referenced by do\+\_\+handshake().

