#SSL/TLS project note
[<img src="http://www.slashroot.in/sites/default/files/ssl%20handshake%20protocol.png">]
##Record Layer
Il record è l'unità di base composta da 5 byte:
### Type(1Byte): 
Specifica il tipo di record, si hanno 4 tipi di record:
+ Handshake (0x16): Per lo scambio chiave
+ Change Cipher Spec (0x14) :Specifica il cambio cipher, non è cifrato, effettuato dopo lo scambio chiave. Da questo pacchetto in poi siamo sotto il protocollo e tutto è cifrato
+ Alert (0x15) : Qualcosa è andato storto (può avvenire anche durante l'handshake)
+ Application Data (0x17) :Scambio dati sotto il protocollo

### Version(2Byte)
Specifica la versione del protocollo: (da vedere con quali byte si indica)
forse 1Byte per major e 1 byte per minor.
Alcuni sono:
SSL 3.0                   3,0  0x0300
TLS 1.0                   3,1  0x0301
TLS 1.1                   3,2  0x0302
TLS 1.2                   3,3  0x0303

### Length (2Byte)
La lunghezza in byte del messaggio escluso l'header. 

##Handshake Layer

L'handshake è un layer sopra il record, autoesplicativo a cosa serve.
Il formato del protocollo è:
- Type (1 Byte)
    Si utilizzano i seguenti messaggi:
    + HELLO_REQUEST            0   (x'00')
    + CLIENT_HELLO             1   (x'01')
    + SERVER_HELLO             2   (x'02')
    + CERTIFICATE             11   (x'0B')
    + SERVER_KEY_EXCHANGE     12   (x'0C')
    + CERTIFICATE_REQUEST     13   (x'0D')
    + SERVER_DONE             14   (x'0E')
    + CERTIFICATE_VERIFY      15   (x'0F')
    + CLIENT_KEY_EXCHANGE     16   (x'10')
    + FINISHED                20   (x'14') 

- Length (3 Byte) 
    Ma che cazzata, la lunghezza del messaggio è in 3 byte ma è contenuto 
    in uno la cui lunghezza è in 2 byte...

- Version (2 Byte)
    Da vedere la differenza con la version dell'intero pacchetto

##ClientHello
- **Header del record** (5 Byte)
- **Header del handshake layer** (6 Byte)
- Random (32 Byte) 
    + Unix time stamp (4 Byte) gmt_unix_time
    + Random (28 Bytes) 
- Session ID (variable Byte)
    + Lenght (1 Byte)
    + Session ID variable : da capire che manda
- Cipher Suite (lunghezza variabile)
    + Cipher suite Length (2 Byte)
    + Cipher suite List : ogni cipher suite è identificata da 2 byte
    **Alcuni esempi:**
        + TLS_EMPTY_RENEGOTIATION_INFO_SCSV       (0x00ff)
        + TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)
        + TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
        + TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xc024)
        + TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xc023)
        + TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    (0xc00a)
        + TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    (0xc009)
        + TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA   (0xc008)
        + TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   (0xc030)
        + TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   (0xc02f)
        + TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   (0xc028)
        + TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   (0xc027)
        + TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      (0xc014)
        + TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      (0xc013)
        + TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     (0xc012)
        + TLS_DHE_RSA_WITH_AES_256_GCM_SHA384     (0x009f)
        + TLS_DHE_RSA_WITH_AES_128_GCM_SHA256     (0x009e)
        + TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     (0x006b)

        + TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     (0x0067)
        + TLS_DHE_RSA_WITH_AES_256_CBC_SHA        (0x0039)
        + TLS_DHE_RSA_WITH_AES_128_CBC_SHA        (0x0033)
        + TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       (0x0016)
        + TLS_RSA_WITH_AES_256_GCM_SHA384         (0x009d)
        + TLS_RSA_WITH_AES_128_GCM_SHA256         (0x009c)
        + TLS_RSA_WITH_AES_256_CBC_SHA256         (0x003d)
        + TLS_RSA_WITH_AES_128_CBC_SHA256         (0x003c)
        + TLS_RSA_WITH_AES_256_CBC_SHA            (0x0035)
        + TLS_RSA_WITH_AES_128_CBC_SHA            (0x002f)
        + TLS_RSA_WITH_3DES_EDE_CBC_SHA           (0x000a)
        + TLS_ECDHE_ECDSA_WITH_RC4_128_SHA        (0xc007)
        + TLS_ECDHE_RSA_WITH_RC4_128_SHA          (0xc011)
        + TLS_RSA_WITH_RC4_128_SHA                (0x0005)
        + TLS_RSA_WITH_RC4_128_MD5                (0x0004)
- Compression (2 byte) 
    uno per la lunghezza e uno per l'identificatore 
    nell'implementazione mettiamo 01 00 e siamo a posto
    (tanto lo dicono pure loro che non ci sono pratiche implementazioni)
- Extension (lunghezza variabile)
    nell'implementazione la possiamo sostituire con 00 in prima battuta
    + Extension Lenght (2 Byte)
    + per ogni estensione :
        - Type (2 Byte)
        - Lenght (2 Byte)
        - Data 

Nel test con google, nel caso di un reasuming di una sessione, viene usata un'estensione per lo scambio del SessionTicket ()

###Riassumendo
struct {
  ProtocolVersion client_version;
  Random random;
  SessionID session_id;
  CipherSuite cipher_suites<2..2^16-2>;
  CompressionMethod compression_methods<1..2^8-1>;
  select (extensions_present) {
      case false:
          struct {};
      case true:
          Extension extensions<0..2^16-1>;
  };
} ClientHello;

##ServerHello
Ricevuto il *ClientHello* il server controlla il pacchetto e risponde con ServerHello a meno che:
+ non trova una suite che può usare -> HANDSHAKE_FAILURE alert
+ ... altri errori in Errors

La struttura del pacchetto ServerHello è identica a quella del ClientHello.
+ Il server sceglie UNA ciphersuite, non abbiamo una lista con length ecc ma dopo il session ID vi sono i 2 Byte che identificano la cipher suite.
+ Il server sceglie UNA compressione (non ne abbiamo) inviando direttamente il Byte
senza length o altro(come per la ciphersuite)
+ Le extensions possono essere diverse (da vedere)
+ Se il sessionID è valido allora risponde con lo stesso sessionID, a tal proposito 
nel test di una connessione con google il sessionID (sia nel ClientHello sia nel serverHello) è dato da 53455353494f4e2d5449434b4554 = (ASCII)SESSION-TICKET
+ Il random NON è uguale al random precedente (ovviamente nemmeno il timestamp)



#Errors
unexpected_message
      An inappropriate message was received.  This alert is always fatal
      and should never be observed in communication between proper
      implementations.

bad_record_mac
  This alert is returned if a record is received with an incorrect
  MAC.  This alert also MUST be returned if an alert is sent because
  a TLSCiphertext decrypted in an invalid way: either it wasn't an
  even multiple of the block length, or its padding values, when
  checked, weren't correct.  This message is always fatal and should
  never be observed in communication between proper implementations
  (except when messages were corrupted in the network).

decryption_failed_RESERVED
  This alert was used in some earlier versions of TLS, and may have
  permitted certain attacks against the CBC mode [CBCATT].  It MUST
  NOT be sent by compliant implementations.

record_overflow
  A TLSCiphertext record was received that had a length more than
  2^14+2048 bytes, or a record decrypted to a TLSCompressed record
  with more than 2^14+1024 bytes.  This message is always fatal and
  should never be observed in communication between proper
  implementations (except when messages were corrupted in the
  network).

decompression_failure
  The decompression function received improper input (e.g., data
  that would expand to excessive length).  This message is always
  fatal and should never be observed in communication between proper
  implementations.

handshake_failure
  Reception of a handshake_failure alert message indicates that the
  sender was unable to negotiate an acceptable set of security
  parameters given the options available.  This is a fatal error.

no_certificate_RESERVED
  This alert was used in SSLv3 but not any version of TLS.  It MUST
  NOT be sent by compliant implementations.

bad_certificate
  A certificate was corrupt, contained signatures that did not
  verify correctly, etc.

unsupported_certificate
  A certificate was of an unsupported type.

certificate_revoked
  A certificate was revoked by its signer.

certificate_expired
  A certificate has expired or is not currently valid.

certificate_unknown
  Some other (unspecified) issue arose in processing the
  certificate, rendering it unacceptable.

illegal_parameter
  A field in the handshake was out of range or inconsistent with
  other fields.  This message is always fatal.

unknown_ca
  A valid certificate chain or partial chain was received, but the
  certificate was not accepted because the CA certificate could not
  be located or couldn't be matched with a known, trusted CA.  This
  message is always fatal.

access_denied
  A valid certificate was received, but when access control was
  applied, the sender decided not to proceed with negotiation.  This
  message is always fatal.

decode_error
  A message could not be decoded because some field was out of the
  specified range or the length of the message was incorrect.  This
  message is always fatal and should never be observed in
  communication between proper implementations (except when messages
  were corrupted in the network).

decrypt_error
  A handshake cryptographic operation failed, including being unable
  to correctly verify a signature or validate a Finished message.
  This message is always fatal.

export_restriction_RESERVED
  This alert was used in some earlier versions of TLS.  It MUST NOT
  be sent by compliant implementations.

protocol_version
  The protocol version the client has attempted to negotiate is
  recognized but not supported.  (For example, old protocol versions
  might be avoided for security reasons.)  This message is always
  fatal.

insufficient_security
  Returned instead of handshake_failure when a negotiation has
  failed specifically because the server requires ciphers more
  secure than those supported by the client.  This message is always
  fatal.

internal_error
  An internal error unrelated to the peer or the correctness of the
  protocol (such as a memory allocation failure) makes it impossible
  to continue.  This message is always fatal.

user_canceled
  This handshake is being canceled for some reason unrelated to a
  protocol failure.  If the user cancels an operation after the
  handshake is complete, just closing the connection by sending a
  close_notify is more appropriate.  This alert should be followed
  by a close_notify.  This message is generally a warning.

no_renegotiation
  Sent by the client in response to a hello request or by the server
  in response to a client hello after initial handshaking.  Either
  of these would normally lead to renegotiation; when that is not
  appropriate, the recipient should respond with this alert.  At
  that point, the original requester can decide whether to proceed
  with the connection.  One case where this would be appropriate is
  where a server has spawned a process to satisfy a request; the
  process might receive security parameters (key length,
  authentication, etc.) at startup, and it might be difficult to
  communicate changes to these parameters after that point.  This
  message is always a warning.

unsupported_extension
  sent by clients that receive an extended server hello containing
  an extension that they did not put in the corresponding client
  hello.  This message is always fatal.

#Pensieri sparsi
non appendiamo zeri perché tanto ci pensa chi sta sotto (TCP/IP)
#da vedere:
+ (se c'è tempo)extension : http://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml
poiché il protocollo non supporta alcuni dettagli (come il nome del server ed altro (vedi link)) abbiamo le estensioni.
Nel link alcune(??) estensioni supportate, il primo numero è l'identificatore che è posto all'inizio dell'estensione

general with packet spec : http://blog.fourthbit.com/2014/12/23/traffic-analysis-of-an-ssl-slash-tls-session
+ usare il multithread non il fork (ptread())
+ openssl s_client -connect google.com:443 -debug 